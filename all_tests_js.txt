   
                                                                 Java Script-ի պատմությունը  

     1995թ-ին գոյություն ուներ Netscape ընկերություն,որը ուներ Netscape Navigator այն ժամանակ հայտնի բրաուզերներից մեկը(այդ ժամանակ ինքն էր մեկ էլ Internet Explorer-ը)։
 
 1995թ-ին Netscape ընկերությունը որոշեց իր բրաուզերի մեջ տեղադրել ծրագրավորման լեզու,որպեսզի կայք ստեղծողները բացի HTML, CSS-ից լոգիկա մտցնեն կայքի մեջ,որպեսզի կայքը 
 
 լինի ավելի դինամիկ։Նրանք գործի ընդունեցին Բրենդն Այկին,որը 10 օրում հորինեց մի հատ ծրագրավորման լեզու, գրեց թարգմանիչ այն ծրագիրը,որը կարողանում է կարդա,հասկանա,

 թարգմանի  այդ կոդերը վերածի 0-ների և մեկերի և փոխանցի բրաուզերին։ Ծրագրավորման լեզուն անվանեց Livescript: Այդ ժամանակ Netscape ընկերությունը համագործակցում էր 

 Microsystems  ընկերության հետ,որը ուներ մեկ այլ ծրագրավորման լեզու՝ Java-ն։ Netscape ընկերության մարկետոլոգները որոշեցին իրենց ծրագրավորման լեզվի անունը փոխել Java 

 Script: Բայց երբ Netscape-ը բաց թողեց Java Script-ը, կայք ստեղծողների ստեղծած կայքերը  Internet Explorer-ում չէր աշխատում։Եվ Microsoft-ը ստեղծեծ իր թարգմանիչ 

 համակարգը,որպեսզի Java Script լեզվով գրված կայքերը աշխատեին նաև Internet Explorer-ում։Բայց դա բերեց որոշ խնդիրներ,որովհետև ոչ մի ստանդարտ չկար,թե Java Script-ի 

 օրենքները որն են,ոնց պետք է աշխատի Java Script-ը,դրա համար Netscape-ը ստեղծեց մի ստանդարտ,ստանդարտի անունը դրեցին Ecma Script։Բայց ինչի ոչ Java Script,որովհետև Java 

 անունը պատկանում էր Microsoft-ին և կարող էր դատի տալ հեղինակային անվան համար։ Ընթացքում ստեղծվեցին ուրիշ բրաուզերներ,որոնք ստեղծեցին իրենց թարգմանիչ համակարգերը ,
 
 որոնք կարողանում էին կարդալ Java Script-ը,այդ թարգմանիչ համակարգերը անվանում են կամ Java Script Runtime կամ  Execution Engine, որը թարգմանվում է որպես աշխատացնող 

շարժիչ։ Ամենահայտնի աշխատացնող շարժիչը Google Chrome-ի մեջ է,որ կոչվում է V-8, որը բավականին արագ է։Քանի որ բրաուզերները իրար հետ մրցում են,որպեսզի ավելի շատ օգտատերեր 

 ունենան, ամեն մեկը փորձում էր ստեղծել հնարավորինս արագ Execution Engine և մրցակցության արդյունքում թարգմանիչ համակարգերը բավականին արագացան։  

                      
                                                                         Node.js         


    2009թին մի հատ շատ խելացի տղա՝ Ռայան Դալը ստեղծեց մի պրոեկտ,որը կոչեց Node.js: Ինքը վերցրեց V-8 աշխատացնող շարժիչը, որը կարողանում է թարգմանել Java Script-ը և 

 տեղադրեց իր պրոեկտի մեջ,որպեսզի կարողանա աշխատացնել Java Script-ը բրաուզերից դուրս։Երկրորդ բանը,որ նա արեց ստեղծեց ֆունկցիաներ,որպեսզի Java Script-ի միջոցով կանչվեն 

 C++  ֆունկցիաները։Այսինքն նա ուներ C++ կոդ և ուներ գրված Java Script-ը և Java Script-ի միջոցով մենք կարողանում ենք խոսել C++ ֆունկցիաների հետ։ C++ ֆունկցիաները 

 հնարավորություն են տալիս օրինակ շփվել  ֆայլ համակարգի հետ, հնարավորություն են տալիս ստեղծել http սերվեր և լիքը ուրիշ հետաքրքիր բաներ։ Եվ ահա մենք ունենք Node.js 

 համակարգը, որը հնարավորությունա տալիս Java Script-ով ստեղծել հետաքրքիր պրոեկտներ բրաուզերից դուրս։  




                                                                       V8 (JavaScript շարժիչ) 


     V8, Javascript ծրագրավորման համար նախատեսված բաց ներքին կոդով շարժիչ, որը տարածվում է BSD լիցենզիայով։ Մշակվել է Google ընկերության դանիական մասնաճյուղի կողմից։

  V8-ի մշակումը սկսվել է Դանիայի Օրխուսե քաղաքում գտնվող Google-ի մասնաճյուղի կողմից։ Ղեկավարող մշակողը դարձավ Լարս Բակը։ Հիմնական խնդիրը, որը պետք է լուծեին 

 ծրագարվորողները այս շարժիչում՝ արագությունը և հարմարավետությունն էր։  Շարժիչի առաջին լաբարատորային տարբերակը թողարկվեց 2008 թվականի հուլիսի 3-ին, իսկ արդեն 

 սեպտեմբերի 2-ին պաշտոնապես թողարկվեց 0․2․5 տարբերակը։ Լարս Բակը համարում է, որ V8-ի անկյունաքարերն են համարվում․

      - JavaScript ներքին կոդի վերծանումը մեքենայական կոդի, շրջանցելով կոդ-բայթի միջանկյալ փուլերը։
      
      - Հիշողության համակարգի արդյունավետ ղեկավարում, որը հանգեցնում է օբյեկտի արագ ընտրմանը և փոքրիկ դադրներով «աղբի» հավաքումը։
    
      - V8-ում դադարեցնում է կոդի իրագործումը «աղբի հավաքման շրջանում»

      - V8-ը կարող է հստակ սահմանել, թե հիշողության, որ մասում է գտնվում օբյեկտը, որը թույլ է տալիս խուսափել տվյալների արտահոսքից։ V8 շարժիչը տարբերվում է մնացած 

 շարժիչներից (JScript, SpiderMonkey, JavaScriptCore, Nitro), իր հզորությամբ։



                                                                            
                                                                            Compiliator 

  
    կոմպիլյատորը սկզբնական կոդը փոխակերպում է մեքենայի կոդի՝ ծրագիրը գործարկելուց առաջ: Սխալների մասին զգուշացումներն անում է միանգամից և կամպիլյացիայի ավարտից հետո։ 

 Կոմպիլյատորը, մյուս կողմից, չի կատարում ծրագիրը տող առ տող, նախ՝ այն հաջորդաբար վերլուծում և վերլուծում է ծրագրի կոդը, կատարում է անհրաժեշտ օպտիմալացումները և միայն

 դրանից հետո ստեղծում մեքենայի կոդ, որը հետագայում կսկսի գործել: Հետևաբար, կազմելիս ավելի շատ ժամանակ է պահանջվում գործարկման համար, քանի որ դրա բոլոր փուլերը պետք է 

 անցնեն սկզբում: Բայց միևնույն ժամանակ, կոմպիլյատորը օպտիմիզացնում է կոդը՝ դրա արագությունը մեծացնելու համար։ Օրինակ, օղակները կաշխատեն ավելի արագ, քանի որ 

 օպտիմիզացումից հետո կարիք չկա կրկնել նույն կոդի վերլուծության քայլերը հանգույցով յուրաքանչյուր անցման համար: Բացի այդ, կոմպիլյատորը կարող է անմիջապես հայտնել, որ 

 կոդի մեջ սխալ կա: Կոմպիլյացնող ծրագրավորման լեզուների օրինակներ են C, C++, Java-ն:  
      
                                               


                                                                     Interpreter  


    Թարգմանիչ ծրագիր է, որն իրականացնում է տող առ տող վերլուծություն, մշակում և ծրագրի սկզբնական կոդի կատարում: Յուրաքանչյուր սխալի հանդիպելուց անմիջապես կատարվում է 

 զգուշացում։ Պարզ թարգմանիչը վերլուծում և անմիջապես կատարում է ծրագիրը տող առ տող (հրաման ըստ հրամանի), քանի որ դրա սկզբնական կոդը հասնում է: Այս մոտեցման 

 առավելությունը հրամանների ակնթարթային արձագանքն է: Ահա թե ինչու բրաուզերներն առաջին անգամ օգտագործեցին JavaScript թարգմանիչներ: Ի վերջո, շատ կարևոր է, որ կոդը արագ 

 աշխատի և աշխատի: Թերությունն այն է, որ թարգմանիչը պետք է կատարի նույն աշխատանքը, երբ դուք օգտագործում եք նույն կոդը մի քանի անգամ: Օրինակ, եթե դուք գտնվում եք 

 հանգույցում, թարգմանիչը նորից ու նորից կվերլուծի նույն տողերը: Այսինքն՝ տող առ տող նման վերլուծությամբ օպտիմալացում չկա ու ավելորդ աշխատանք է առաջանում։ Նաև նման 

 թարգմանիչը կոդում սխալներ է հայտնաբերում միայն այն դեպքում, երբ փորձում է սխալով տողը կատարել: Իսկ կոդի սխալի մասին ի սկզբանե հնարավոր չէ հայտնել։ Ինտերպրետացվող 

 լեզուների օրինակներ են Perl-ը, Python-ը, Matlab-ը, Javascript-ը, PHP-ն:



                                                                       
                                                                     Just-in-time compilation (JIT կոմպիլյացիա)  


       JIT-կոմպիլյացիան մեքենայական կոդը թարգմանելու երկու ավանդական գաղափարների կոմբինացիա է՝ AOT-կոմպիլյացիա և ինտերպրետացիա, և իր մեջ համատեղում է երկուսի որոշ 

 առավելություններ և թերություններ։ Այս երկու մոտեցումներից լավագույնն օգտագործելու համար բրաուզերները սկսել են դրանք համատեղել: Չնայած տարբեր բրաուզերներ դա անում են 

 մի փոքր այլ կերպ, այս գաղափարի էությունը նույնն է՝ դինամիկ կոմպիլյացիայի օգտագործումը (անգլերեն Just-in-time compilation, JIT կոմպիլյացիան): JavaScript շարժիչին 

 ավելացվել է պրոֆիլավորիչ կոչվող գործիք, որը համակարգին ասում է, թե որ մեթոդների վրա է ծրագիրը ծախսում ամենաշատ ժամանակը, որպեսզի հետագայում դրանք կարողանան 

 օպտիմալացնել:  Երբ JavaScript կոդը առաջին անգամ գործարկվում է, այն ամբողջությամբ գործարկվում է կոմպիլյատորի միջոցով, որն անմիջապես, առանց լրացուցիչ օպտիմալացումների, 

 այն վերածում է մեքենայի կոդի: Սա թույլ է տալիս մեզ սկսել այն շատ արագ կատարել կամ հայտնել սխալների մասին մեր կոդի վաղ փուլում: (Այժմ ժամանակակից շարժիչներում այլևս 

 չեն օգտագործում թարգմանիչներ տող առ տող վերլուծության և կոդի կատարման համար, նույնիսկ JavaScript ծրագրի առաջին իսկ գործարկման ժամանակ): Կոդը որոշ ժամանակ աշխատելուց 

 հետո պրոֆիլավորողը կհավաքի բավականաչափ տվյալներ, որպեսզի համակարգը կարողանա հասկանալ, թե որ մեթոդներն են պետք օպտիմալացնել: Օրինակ, երբ նույն ֆունկցիան կատարվում է 

 մի քանի անգամ, կոմպիլյատորն այն վերցնում է առանձին՝ աշխատելու համար։ Որտեղ այն օպտիմիզացված է և պահպանվում է նոր ձևով: Հաջորդ անգամ, երբ այս ֆունկցիան կանչվի, 

 կկանչվի դրա օպտիմիզացված տարբերակը՝ դրանով իսկ արագացնելով դրա կատարման գործընթացը:


  
                                                       HTTP - Hypertext Transfer Protocol –(Հիպերտեքստի փոխանցման արձանագրություն) 



 Հիպերտեքստի փոխանցման արձանագրությունը (HTTP)  կիրառական արձանագրություն է՝ HTML-ի նման հիպերտեքստային փաստաթղթերի փոխանցման համար: Այն ստեղծվել է վեբ բրաուզերների և

 վեբ սերվերների միջև հաղորդակցության համար, թեև սկզբունքորեն HTTP-ն կարող է օգտագործվել այլ նպատակների համար: Արձանագրությունը հետևում է հաճախորդի/սերվերի դասական 

 մոդելին, որտեղ հաճախորդը կապ է բացում հարցում կատարելու համար, այնուհետև սպասում է պատասխանի: HTTP-ը  պետականություն չունեցող արձանագրություն է, ինչը նշանակում է, 

 որ սերվերը չի պահում որևէ տվյալ (վիճակ) երկու հարցում-պատասխան զույգերի միջև: Չնայած HTTP-ն հիմնված է TCP/IP-ի վրա, այն կարող է նաև օգտագործել ցանկացած այլ 

 երաշխավորված առաքման տրանսպորտային շերտի արձանագրություն:





   Հիպերտեքստը հաշվարկման հետ կապված հասկացություն է: Այն վերաբերում է համակարգին, որը թույլ է տալիս տեքստերի բեկորներ կապել միմյանց հետ, ինչը թույլ է տալիս օգտվողին 

 տեղեկատվություն ստանալ հարակից իրերի միջոցով ՝ դրանք հաջորդաբար կատարելու փոխարեն: Հիպերտեքստ հասկացությունը ստեղծվել է 1960-ականներին ամերիկացի փիլիսոփա և սոցիոլոգ 

 Թեոդոր Հոլմ Նելսոնի կողմից `նշանակելու համար նոր ոչ գծային և ինտերակտիվ ընթերցում, որն առաջացել է համակարգչով և ինտերնետի ի հայտ գալով: Հիպերտեքստային գործընթացն 

 իրականացնելու համար Համաշխարհային ցանցը (www) օգտագործեց HTTP պրոտոկոլը, որի հապավումն է Հիպեր տեքստի փոխանցման արձանագրություն, ինչը իսպաներեն նշանակում է Hypertext 

 Transfer Protocol, որը բաղկացած է տեղեկատվական համակարգերի միջև հաղորդակցման արձանագրությունից, որը թույլ է տալիս տվյալների փոխանցում համակարգչային ցանցերի միջև ՝ 

 HTML էջերը կամ վեբ էջերն ու մուլտիմեդիա ֆայլերը կապելու համար: Հիպերտեքստի հայտնի օրինակ են ինտերնետային հոդվածները, որոնք տեքստի մարմնում ներկայացնում են տարբեր 

 հղումներ կամ հիպերտեքստային հղումներ բառերի կամ թեմաների մեջ, որոնք առնչվում են հիմնական թեմային կամ մշակման մեջ, ինչը թույլ է տալիս ընթերցողին ավելի ակտիվ և 

 ընթերցանություն ունենալ ընտրելով այն տեղեկատվությունը, որը նախընտրում եք մուտք գործել: Մենք կարող ենք նաև նշել բառարաններ, հանրագիտարաններ և այլն։
       
     Դա կիրառական արձանագրություն է հիպերտեքստային փաստաթղթերի փոխանցման համար, ինչպիսիք են HTML-ը: Այն ստեղծվել է վեբ բրաուզերների և վեբ սերվերների միջև հաղորդակցության համար, թեև սկզբունքորեն HTTP-ն կարող է օգտագործվել այլ նպատակների համար: Արձանագրությունը հետևում է հաճախորդ-սերվերի դասական մոդելին, որտեղ հաճախորդը կապ է բացում հարցում կատարելու համար, այնուհետև սպասում է պատասխանի: HTTP-ն արձանագրություն է առանց իրավիճակի պահպանման, այսինքն՝ սերվերը չի պահում որևէ տվյալ (վիճակ) երկու հարցում-պատասխան զույգերի միջև։ Չնայած HTTP-ն հիմնված է TCP/IP-ի վրա, այն կարող է նաև օգտագործել ցանկացած այլ տրանսպորտային շերտի արձանագրություն՝ երաշխավորված առաքմամբ:
 
 Տարբեր գործողություններ, որոնք կատարվում են HTTP-ով`

   1․ Get - մեթոդը հարցում է կատարում սահմանված ռեսուրսի ցուցադրման համար։ GET մեթոդով հարցումները կարող են միայն ստանալ տվյալներ և չեն կարող ունենալ այլ ազդեցություն 

 (Սա հատուկ է նաև որոշ այլ HTTP մեթոդների)։ (response/ data պատասխան, արդյունք

   2. Post - POST HTTP մեթոդը նախատեսված է տվյալներ սերվեր ուղարկելու համար: ) (request - հարցում)


  



 3. կարդում եք HTTP https://developer.mozilla.org/ru/docs/Web/HTTP  -

 4․ կարդում եք  V8 (движок JavaScript) https://ru.wikipedia.org/wiki/V8_(%D0%B4%D0%B2%D0%B8%D0%B6%D0%BE%D0%BA_JavaScript)  -

 5․ VS Code extensions   +

     All Autocomplete
     Auto Close Tag
     Auto Complete Tag
     Auto Import
     Auto Rename Tag
     Bearded Icons
     Bearded Theme
     Beautify
     Code Runner
     Git History
     Import Cost
     JavaScript (ES6) code snippets
     JavaScript Snippet Pack
     Jest Runner
     Live Server
     Multiple clipboards for VSCode
     Path Autocomplete
     jshint

  6․ կարդում եք scope-երի մասին  https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/block (ռուսերեն)  -

  7․ var,let,const տարբերությունը՝  -
     https://medium.com/nuances-of-programming/%D0%B2-%D1%87%D1%91%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-var-let-%D0%B8-const-%D0%B2-javascript-3084bfe9f7a3

 8․  JS ֆայլի մեջ ստեղծում եք 4 հատ Block scope, և անում եք այնպես, որ երկու բլոք սքոփերը բոլորին տեսնեն իսկ էն մյուս  երկուսը ոչ մեկին չտեսնեն  -

 9․ գրում եք 10 հատ փոփոխականի անուն camelCase-ով  +

 10․ կարդում եք Ռուսերեն  Типы данных JavaScript и структуры данных   https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures  -

 11․ Որոնում և գտնում եք Block Scope-ի և Function Scope-ի տարբերությունները և գրում եք հայերեն լեզվով ձեր տնայինի մեջ txt ֆայլում   -

 12․ հայերենով բացատրում եք (գրում եք ֆայլի մեջ) թե ինչի՞ ա TypeScript ֆայլը տեսնում JavaScript Ֆայլի մեջի եղածը, իսկ հակառակը ոչ  -

 13․ հայերենով բացատրում եք թե ինչի՞ ա NULL-ի թայփը օբջեքթ  -
 
 14․ ստեղծում եք օբջեքթ, որի մեջ նկարագրում եք ձեր սիրած բանաստեղծին, անուն, ազգանուն, տարիք, որտեղ ա ապրել, հետո զանգվածով թվարկում եք ձեր սիրած 
 բանաստեղծությունների անունները, հետո օբջեքթի մեջ ստեղծում եք մեթոդ, որը պետք ա կանսոլ անի էն բանաստեղծությունը, որը կստանա կանչվելու ժամանակ   +

 15․ Տնային աշխատանք։ Ստեղծում եք Object, որը ունենում ա մեթոդ, որի մեջ իրականացնում եք մաթեմատիկական գործողություն, ու արդյունքը տպում եք կանսոլում։ 
 Մաթեմատիկական գործողությունը պետքա  բաղկացած լինի գոնե երկու օպերատորից (+, -, /, *)   +

 16․  Կրկնում եք JS-ի օպերատորները, որոնք այս դասի ընթացքում անցել ենք https://www.w3schools.com/js/js_operators.asp   +
  
 17․ կարդում եք օպերատորների պրիարետը https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence   -

 18․ գրում եք Object, որի մեջ կա մեթոդ, մեթոը ստանում ա 2 արգումենտ (parameter), ու կոնսոլում ստուգում եք հետևյալ օպերատորերով՝ <, >, <=, >=, !=, ==, !==, ===, !   +

 19․ Եթե ցանկություն կա, ապա կարող եք կարդալ բիթային օպերատորները https://learn.javascript.ru/bitwise-operators   -

 20․ ստեղծում եք Object որը իր մեջ կունենա Method և property-ներ, Method-ը պետք ա ինչ-որ տվյալներ վերադարձնի կանսոլում որոնք վերցնելու ա property-ներից։   +

 21․ ստեղծում եք 10 հատ if, else if, else հրամաններով, օգտագործել այդ երեքը   +

 22․ ստեղծում եք 1 հատ if, else և ապահովում եք ճյուղավորում  +

 23․  ստեղծում ենք 10 հատ ternary օպերատորով ստուգումներ, որոնցից 2ը պետք ա լինի սթրինգի մեջ   +

 























 